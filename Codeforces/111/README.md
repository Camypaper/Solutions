#CF111まとめ
##[Div2A:Twins](http://codeforces.com/contest/160/problem/A)
+ タグ: Implementation
+ 概要:  
**N**枚のコインがある．i番目のコインは**V**_iの価値を持つ．全体の半分よりも価値が大きくなるときの取る枚数の最小を求めよ．
+ 制約:  
1<=**N**<=100  
1<=**V**_i<=100  
+ 時間制限: 2sec
+ メモリ制限: 2MB
+ 解法:  
総和をとって価値の大きいほうから選ぶ．持っているコインの価値が全体の半分よりも価値が大きくなったら打ち切り．_O(NlogN)_でできる．
+ コメント:  
文章が無駄に長くて困る．

##[Div2B:UnluckyTicket](http://codeforces.com/contest/160/problem/A)
+ タグ: Graph Biparate_Graph Matching
+ 概要:  
2\***N**個の数字からなる数が与えられる．前半のある数字と後半のある数字をそれぞれペアにすることを考える．このとき，すべてのペアについて前半の数が後半の数よりも大きい，またはすべてのペアについて前半の数が後半の数よりも小さいように選ぶことができるとき，Unluckyである．数がUnluckyかどうか判定せよ．
+ 制約:  
1<=**N**<=100
+ 時間制限: 2sec
+ メモリ制限: 2MB
+ 解法:  
2部マッチングする．
+ コメント:  
貪欲にやるよりライブラリペタリする方が楽だよね．

##[Div2C:FindPair](http://codeforces.com/contest/160/problem/3)
+ タグ: Sorting
+ 概要:  
**N**個の数が与えられる．**N**^2個のペアを作ってソートしたときの**k**番目のペアを答えよ．なお，ソート時のキーはペアの1番目でまず比較し，それが同一ならば2番目で比較することとする．
+ 制約:  
1<=**N**<=100,000
+ 時間制限: 1sec
+ メモリ制限: 2MB
+ 解法:  
愚直に調べるとTLEする．うまくサボりたい．とりあえずソートしたあると数えやすいことは分かる．正解のペアを{i,j}とする．すべての値がDistinctな場合**k**-1==i\*n+jを満たせばよい．そうでないときはcount(a[i])\*nのグリッドの中から選ぶようなイメージでやる．はみでるときは次のグリッドに進んでいくようにやればよい．
+ コメント:  
割と面白い問題．

##[Div2D:Edges in MST](http://codeforces.com/contest/160/problem/4)
+ タグ: Graph MST Bridge
+ 概要:  
**N**個の頂点からと**M**本の重み付きの辺からなるグラフが与えられる．それぞれの辺について，最小全域木を作ったときに必ず使うか，使われることがあるか，全く使われないか判定せよ．
+ 制約:  
2<=**N**<=100,000
**N**-1<=**M**<=Min(10,000,**N**\*(**N**-1)/2)
+ 時間制限: 2sec
+ メモリ制限: 256MB
+ 解法:  
クラスカル法+橋の列挙．辺のコストでソートを行う．同じコストの辺の集合について，橋となるかどうかを判定する．その際，すでにつながっている頂点同士を用いる辺は無視する．_O(|E|log|E|)_でできる．
+ コメント:  
Div2Dにしてはとても難しいと思う．
