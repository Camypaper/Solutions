#Bitwise2015まとめ
Bitwise2015にいちょうさんとumaibento(四川屋台のツイッターアカウントが元ネタ)で出た．結果は8完で10位．解いたのはそのうち3問．

##[A:HolaBola is hiring](https://www.hackerrank.com/contests/bitwise2015/challenges/holabola1)
+ タグ: Math
+ 概要:  
N人の人がいる．二種類の仕事A,Bがある．N人のうち何人かを雇うかどうかを決める．A,Bを雇った人のうちの誰かに任せたい(一人がどちらもやってもよい)．雇い方と仕事の任せ方は何通りあるか．mod 1e9+7で答えよ．
+ 制約:  
1<=N<=10^18
+ 時間制限: 3sec(C#)
+ メモリ制限: 512MB(C#)
+ 解法:  
一人でどちらの仕事をこなすパターンと二人で仕事をこなすパターンを考える．N*2^n-1+(N^2-N)*2^n-2が答えになる．
+ コメント:  
A問題だけあって簡単め

##[B:The Jungle of Rooted Trees](https://www.hackerrank.com/contests/bitwise2015/challenges/jungletrees)
+ タグ: Graph Tree Merge_Data_Structure
+ 概要:  
根付き木が与えられる．ある木が持つ値は部分木のある深さのノード数をkとしたときにΣk^2(0<=k<=N)で与えられる．各ノードが持つ値を答えよ．
+ 制約:  
1<=N<=10,000
+ 時間制限: 3sec(C#)
+ メモリ制限: 512MB(C#)
+ 解法:  
愚直に数えると_O(N^2)_で間に合わない．いい感じにやって_O(NlogN)_で抑えたい．がんばって考えると子の部分木における深さiのノード数をdequeで管理すると増減を管理できそうなことがわかる．木dfsしながらdequeをマージしていけばよい．その際，サイズが大きいdequeにサイズが小さいdequeの中身を移していけばよい(データ構造をマージする一般的なテク)．これでO(NlogN)でできる．
+ コメント:  
実際のところ，普通に木dfsするとスタックオーバーフローする．つらい．データ構造をマージする一般的なテクを使うのはじめてかも

##[I:Music and Happiness](https://www.hackerrank.com/contests/bitwise2015/challenges/music-and-happiness)
+ タグ: DP
+ 概要:  
T時間曲を聞きたい．曲はN曲ある．i番目の曲を聞き終わるとt_i時間経過し幸福度h_iが得られる．リピートして聞くこともできるが，再生にかかる時間が1ずつ増加する．曲を途中でスキップするとSかかる．T時間あって得られる幸福度の最大値を求めよ．
+ 制約:  
1<=N<=1,000  
1<=T<=2,000
0<=t_i<=T
0<=h_i<=10,000
0<=S<=T
+ 時間制限: 3sec(C#)
+ メモリ制限: 512MB(C#)
+ 解法:  
ぱっと見DPっぽく実際その通りである．選択肢は2つあり，曲を即座にスキップするか，k回連続で聞くかのどちらかである．100回ほど連続で聞くと確実にTを超えることに気づく．これでDP[i]をi時間たったときの幸福度の最大値としてDPしてやればよい．O(N*T*k)でできる．10^8程度だが，実際には毎回100連続再生することはないので，もっと短く終了する．
+ コメント:  
結構TLEヒヤヒヤしたけどちゃんと終わって安心した．
