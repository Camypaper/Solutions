#ARC035まとめ
##A:[高橋くんと回文](http://arc035.contest.atcoder.jp/tasks/arc035_a)
+ タグ: String Implementation
+ 概要:  
英小文字及び'\*'からなる文字列**S**が与えられる．'\*'が任意の英小文字に変換可能なとき，**S**は回文になりうるか判定せよ．
+ 制約:  
1<=|**S**|<=1,000
+ 制限時間: 2sec
+ メモリ制限 256MB
+ 解法:  
愚直にやればよい．_O(|**S**|)_でできる．  
+ コメント:  
やるだけ．
##B:[アットコーダー王国のコンテスト事情](http://arc035.contest.atcoder.jp/tasks/arc035_b)
+ タグ: Sorting DP
+ 概要:  
**N**個の問題からなるコンテストがある．ある問題を解くのに**T**_i時間かかる．ペナルティはコンテスト開始から現在の時間までの時間である．最小のペナルティとそのときの解き方が何通りあるかを答えよ．
+ 制約:  
1<=**N**<=10,000  
1<=**T**_i<=10,000
+ 制限時間: 2sec
+ メモリ制限 256MB
+ 解法:  
解くのにかかる時間が短い方から解くのが良いのでソートする．ペナルティは累積和をとったものの総和で求まる．解くのに**v**かかる問題の数を_count(**v**)_とすると，解く順序は_count(**v**)_!通り存在する．解き方の総数は_count(1)_!\*_count(2)_!\*...\*_count(10,000)_!で表せる．ソートに_O(NlogN)_，数え上げは_O(N)_で可能なので全体として_O(NlogN)_．
+ コメント:  
Bにしては難しい気がする．
##C:[アットコーダー王国の交通事情](http://arc035.contest.atcoder.jp/tasks/arc035_c)
+ タグ: Graph Shortest_Path
+ 概要:  
**N**個の都市と**M**本の道からなる連結無向グラフがある．それぞれの道はある長さ**L_i**をもつ．都市_i_と_j_の間の最短経路長を_D(i,j)_とする．全ての都市間の最短経路長の総和**S**とする．**K**本新たな道を追加することを考える．その時点における**S**を答えよ．
+ 制約:  
1<=**N**<=400  
1<=**M**<=1,000  
1<=**K**<=400  
1<=**L**_i<=1,000
+ 制限時間: 2sec
+ メモリ制限: 256MB
+ 解法:  
ワーシャルフロイド法を用いて各都市間の最短距離を求める．辺が追加されるごとにワーシャルフロイド法を行うと，_O(k*N^3)_となってTLEする．_x_,_y_をつなぐ長さ_z_の辺が追加されたとき，最短経路長が変化するのは_D(i,j)_>_D(i,x)_+z+_D(y,j)_のときあるいは_D(i,j)_>_D(i,y)_+z+_D(x,j)_のときのみである．この更新は_O(N^2)_で行うことができるので，_O(K*N^2)_で行うことができる．全体として_O((N+K)*N^2)_．
+ コメント:  
前にCodeforcesで似たようなことをやったおかげで解けた．
##D:[高橋くんとマラソンコース](http://arc035.contest.atcoder.jp/tasks/arc035_d)
+ タグ: Data_Structure
+ 概要:  
10^6\*10^6のグリッドがある．これを南から北へ，西から東へ移動するようにチェックポイントを**N**個作る．あるチェックポイント_u_から_v_への経路数を_count(u,v)_とする．**Q**個のクエリが与えられるのでクエリに答えよ．
 1. **k**番目のチェックポイントの位置を変更する．
 2. _count(l,r)_と_count(u,v)_のどちらが大きいか判定する．ただし，経路数の多い方が少ない方の2倍以上であることが保証されている．
+ 制約:  
2<=**N**<=200,000  
1<=**Q**<=200,000
+ 制限時間: 3sec
+ メモリ制限: 256MB
+ 解法:  
**k**番目のチェックポイントから**k**+1番目のチェックポイントへ移動するときの経路数は東に_dx_，北へ_dy_だけ移動しなくてはならないとき，_(dx+dy)**C**dy_で与えられる．これをクエリごとに数え上げるとTLEする．セグメントツリーを使って管理することで各クエリごとに_O(logN)_で更新，取得が可能になる．しかし，このままではオーバーフローしてしまう．経路数が2倍以上異なることを利用する．経路数を2^m*v(0<=m,1<=v<2)と表して管理してやるとオーバーフローせずに比較することができる．全体として_O(NlogN)_．
+ コメント:  
logで管理するともっと楽に実装できたらしい．
